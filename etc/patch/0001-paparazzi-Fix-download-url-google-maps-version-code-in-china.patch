 data/maps/Makefile                    |   2 +-
 sw/ground_segment/cockpit/Makefile    |   2 +-
 sw/lib/ocaml/convert.c                |   2 +
 sw/lib/ocaml/cserial.c                | 194 +++++++++++++++++++++++++++++++++-
 sw/tools/bluegiga_usb_dongle/Makefile |   2 +-
 5 files changed, 198 insertions(+), 4 deletions(-)

diff --git a/data/maps/Makefile b/data/maps/Makefile
index dd21fe1..61b8ff3 100644
--- a/data/maps/Makefile
+++ b/data/maps/Makefile
@@ -24,7 +24,7 @@ $(DATADIR):
 $(DATADIR)/maps.google.com: $(DATADIR) FORCE
 	@echo "-----------------------------------------------"
 	@echo "DOWNLOAD: google maps version code";
-	$(Q)wget -q -t 1 -T 10 --no-check-certificate -O $(@) http://maps.googleapis.com/maps/api/js || \
+	$(Q)wget -q -t 1 -T 10 --no-check-certificate -O $(@) http://maps.google.cn/maps/api/js || \
 		(rm -f $(@) && \
 		echo "Could not download google maps version code" && \
 		echo "-----------------------------------------------" && \
diff --git a/sw/ground_segment/cockpit/Makefile b/sw/ground_segment/cockpit/Makefile
index 15a9279..95e6e8f 100644
--- a/sw/ground_segment/cockpit/Makefile
+++ b/sw/ground_segment/cockpit/Makefile
@@ -44,7 +44,7 @@ LABLGTK2_VER := $(shell ocamlfind query -format '%v' lablgtk2)
 # major.minor version
 LABLGTK2_MM := $(shell echo $(LABLGTK2_VER) | cut -f1,2 -d.)
 #LABLGTK2_NATIVE_WINDOW := $(shell echo '$(LABLGTK2_MM)>=2.18' | bc)
-ifeq ($(shell echo '$(LABLGTK2_MM)>=2.18' | bc),1)
+ifeq ($(shell [ $(LABLGTK2_MM)>=2.18 ] && echo 1),1)
 CAMLP4_DEFS = -DGDK_NATIVE_WINDOW
 endif
 CAMLP4_DEFS ?=
diff --git a/sw/lib/ocaml/convert.c b/sw/lib/ocaml/convert.c
index 3a16ec5..6905bd5 100644
--- a/sw/lib/ocaml/convert.c
+++ b/sw/lib/ocaml/convert.c
@@ -25,7 +25,9 @@
 
 #include <sys/types.h>
 #include <fcntl.h>
+#if !defined(__MINGW32__)
 #include <sys/termios.h>
+#endif
 #include <stdio.h>
 #include <caml/mlvalues.h>
 #include <caml/alloc.h>
diff --git a/sw/lib/ocaml/cserial.c b/sw/lib/ocaml/cserial.c
index 35f4ffb..29db77e 100644
--- a/sw/lib/ocaml/cserial.c
+++ b/sw/lib/ocaml/cserial.c
@@ -24,20 +24,26 @@
 
 #include <sys/types.h>
 #include <fcntl.h>
+#if !defined(__MINGW32__)
 #include <termios.h>
+#else
+//#include <winodws.h>
+#endif
 #include <stdio.h>
 #include <string.h>
+#if !defined(__MINGW32__)
 #include <sys/termios.h>
 #include <sys/ioctl.h>
+#endif
 
 #include <caml/mlvalues.h>
 #include <caml/fail.h>
 #include <caml/alloc.h>
 #include <caml/memory.h>
 
+#if !defined(__MINGW32__)
 static int baudrates[] = { B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800, B2400, B4800, B9600, B19200, B38400, B57600, B115200, B230400 };
 
-
 /****************************************************************************/
 /* Open serial device for requested protocoll */
 /****************************************************************************/
@@ -128,3 +134,189 @@ value c_serial_set_baudrate(value val_fd, value speed)
   }
   CAMLreturn (Val_unit);
 }
+char comports[38][16]={"/dev/ttyS0","/dev/ttyS1","/dev/ttyS2","/dev/ttyS3","/dev/ttyS4","/dev/ttyS5",
+                       "/dev/ttyS6","/dev/ttyS7","/dev/ttyS8","/dev/ttyS9","/dev/ttyS10","/dev/ttyS11",
+                       "/dev/ttyS12","/dev/ttyS13","/dev/ttyS14","/dev/ttyS15","/dev/ttyUSB0",
+                       "/dev/ttyUSB1","/dev/ttyUSB2","/dev/ttyUSB3","/dev/ttyUSB4","/dev/ttyUSB5",
+                       "/dev/ttyAMA0","/dev/ttyAMA1","/dev/ttyACM0","/dev/ttyACM1",
+                       "/dev/rfcomm0","/dev/rfcomm1","/dev/ircomm0","/dev/ircomm1",
+                       "/dev/cuau0","/dev/cuau1","/dev/cuau2","/dev/cuau3",
+                       "/dev/cuaU0","/dev/cuaU1","/dev/cuaU2","/dev/cuaU3"};
+#elif defined(__MSVC__)
+HANDLE Cport[16];
+char comports[16][10]={"\\\\.\\COM1",  "\\\\.\\COM2",  "\\\\.\\COM3",  "\\\\.\\COM4",
+                       "\\\\.\\COM5",  "\\\\.\\COM6",  "\\\\.\\COM7",  "\\\\.\\COM8",
+                       "\\\\.\\COM9",  "\\\\.\\COM10", "\\\\.\\COM11", "\\\\.\\COM12",
+                       "\\\\.\\COM13", "\\\\.\\COM14", "\\\\.\\COM15", "\\\\.\\COM16"};
+
+char mode_str[128];
+value c_init_serial(value device, value speed, value hw_flow_control)
+{
+  CAMLparam3 (device, speed, hw_flow_control);
+  #if 0
+  //String_val(device)
+  int comport_number = 0;
+  
+  int baudrate = baudrates[Int_val(speed)];
+
+  if((comport_number>15)||(comport_number<0))
+  {
+    printf("illegal comport number\n");
+    return(1);
+  }
+
+  switch(baudrate)
+  {
+    case     110 : strcpy(mode_str, "baud=110");
+                   break;
+    case     300 : strcpy(mode_str, "baud=300");
+                   break;
+    case     600 : strcpy(mode_str, "baud=600");
+                   break;
+    case    1200 : strcpy(mode_str, "baud=1200");
+                   break;
+    case    2400 : strcpy(mode_str, "baud=2400");
+                   break;
+    case    4800 : strcpy(mode_str, "baud=4800");
+                   break;
+    case    9600 : strcpy(mode_str, "baud=9600");
+                   break;
+    case   19200 : strcpy(mode_str, "baud=19200");
+                   break;
+    case   38400 : strcpy(mode_str, "baud=38400");
+                   break;
+    case   57600 : strcpy(mode_str, "baud=57600");
+                   break;
+    case  115200 : strcpy(mode_str, "baud=115200");
+                   break;
+    case  128000 : strcpy(mode_str, "baud=128000");
+                   break;
+    case  256000 : strcpy(mode_str, "baud=256000");
+                   break;
+    case  500000 : strcpy(mode_str, "baud=500000");
+                   break;
+    case 1000000 : strcpy(mode_str, "baud=1000000");
+                   break;
+    default      : printf("invalid baudrate\n");
+                   return(1);
+                   break;
+  }
+
+  if(strlen(mode) != 3)
+  {
+    printf("invalid mode \"%s\"\n", mode);
+    CAMLreturn (Val_int(1));
+  }
+
+  switch(mode[0])
+  {
+    case '8': strcat(mode_str, " data=8");
+              break;
+    case '7': strcat(mode_str, " data=7");
+              break;
+    case '6': strcat(mode_str, " data=6");
+              break;
+    case '5': strcat(mode_str, " data=5");
+              break;
+    default : printf("invalid number of data-bits '%c'\n", mode[0]);
+              CAMLreturn (Val_int(1));
+              break;
+  }
+
+  switch(mode[1])
+  {
+    case 'N':
+    case 'n': strcat(mode_str, " parity=n");
+              break;
+    case 'E':
+    case 'e': strcat(mode_str, " parity=e");
+              break;
+    case 'O':
+    case 'o': strcat(mode_str, " parity=o");
+              break;
+    default : printf("invalid parity '%c'\n", mode[1]);
+              CAMLreturn (Val_int(1));
+              break;
+  }
+
+  switch(mode[2])
+  {
+    case '1': strcat(mode_str, " stop=1");
+              break;
+    case '2': strcat(mode_str, " stop=2");
+              break;
+    default : printf("invalid number of stop bits '%c'\n", mode[2]);
+              CAMLreturn (Val_int(1));
+              break;
+  }
+
+  strcat(mode_str, " dtr=on rts=on");
+
+/*
+http://msdn.microsoft.com/en-us/library/windows/desktop/aa363145%28v=vs.85%29.aspx
+
+http://technet.microsoft.com/en-us/library/cc732236.aspx
+*/
+
+  Cport[comport_number] = CreateFileA(comports[comport_number],
+                      GENERIC_READ|GENERIC_WRITE,
+                      0,                          /* no share  */
+                      NULL,                       /* no security */
+                      OPEN_EXISTING,
+                      0,                          /* no threads */
+                      NULL);                      /* no templates */
+  if (Cport[comport_number] == INVALID_HANDLE_VALUE) failwith("opening modem serial device : fd < 0");
+
+  //if (tcgetattr(fd, &orig_termios)) failwith("getting modem serial device attr");
+  //cur_termios = orig_termios;
+  DCB port_settings;
+  memset(&port_settings, 0, sizeof(port_settings));  /* clear the new struct  */
+  port_settings.DCBlength = sizeof(port_settings);
+  
+  if(!BuildCommDCBA(mode_str, &port_settings))
+  {
+    printf("unable to set comport dcb settings\n");
+    CloseHandle(Cport[comport_number]);
+    CAMLreturn (Val_int(1));
+  }
+
+  if(!SetCommState(Cport[comport_number], &port_settings))
+  {
+    printf("unable to set comport cfg settings\n");
+    CloseHandle(Cport[comport_number]);
+    CAMLreturn (Val_int(1));
+  }
+
+  COMMTIMEOUTS Cptimeouts;
+
+  Cptimeouts.ReadIntervalTimeout         = MAXDWORD;
+  Cptimeouts.ReadTotalTimeoutMultiplier  = 0;
+  Cptimeouts.ReadTotalTimeoutConstant    = 0;
+  Cptimeouts.WriteTotalTimeoutMultiplier = 0;
+  Cptimeouts.WriteTotalTimeoutConstant   = 0;
+
+  if(!SetCommTimeouts(Cport[comport_number], &Cptimeouts))
+  {
+    printf("unable to set comport time-out settings\n");
+    CloseHandle(Cport[comport_number]);
+    CAMLreturn (Val_int(1));
+  }
+  #endif
+  CAMLreturn (Val_int(0));
+}
+
+value c_set_dtr(value val_fd, value val_bit)
+{
+  CAMLparam2 (val_fd, val_bit);
+  CAMLreturn (Val_int(0));
+}
+
+
+/* From the gPhoto I/O library */
+value c_serial_set_baudrate(value val_fd, value speed)
+{
+  CAMLparam2 (val_fd, speed);
+  
+  CAMLreturn (Val_int(0));
+}
+#endif
diff --git a/sw/tools/bluegiga_usb_dongle/Makefile b/sw/tools/bluegiga_usb_dongle/Makefile
index fba9ada..a50e9c8 100644
--- a/sw/tools/bluegiga_usb_dongle/Makefile
+++ b/sw/tools/bluegiga_usb_dongle/Makefile
@@ -8,7 +8,7 @@ MACHINE = $(shell $(CC) -dumpmachine)
 ifneq (,$(or $(findstring mingw, $(MACHINE)), $(findstring cygwin, $(MACHINE))))
 	PLATFORM = WIN
 	LIBS = -lm -lsetupapi
-	RM = del
+	RM = rm
 # POSIX
 else
 	PLATFORM = POSIX
